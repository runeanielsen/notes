* Elixir
** Introduction
Elixir is a pragmatic approach to functional programming. It values functional foundations and it focuses on developer productivity.

Concurrency is the backbone of Elixir software. Elixir is made to free you from antiquated concurrency mechanisms.

*** Functional language
A functional language lets us think in terms of functions that transform data. This transformation never mutates data. Instead, each applicaiton of a function potentially creates a new, fresh version of the data. This reduces the need for data-synchronization mechanisms.

*** Macros
Elixir empowers developers by providing macros. Elixir code is nothing more than data, and therefore can be manipulated via macros like any other value in the language.

*** Erlang VM
In the Erlang VM everything runs in tiny concurrent processes, each with its own state. All communication happens by message-passing, exchanging messages between differnet machines on the same network transparently by the VM, making it a perfect environment for building distributed software.

** Functions are data transformers
Elixir lets us solve problems in the same way that Unix shell does. Rather than command-line utilities, we have functions. These functions we can string together as we please. The smaller and focused they are, the easier they're to reuse and combine.

If we want, we can make these functions run in parallel, Elixir has a simple but powerful mechanism for passing messages between them. This mechanism provides the potential to run millions of them on a single machine and have hundreds of these machines inter-operating.

Bruce Tate commented on this paragraph with this thought:
#+begin_quote
Most programmers treat threads and processes as a necessary evil; Elixir developers feel they are an important simplification. --- Bruce Tate
#+end_quote

** Compile and Run
Elixir files will typically have the extension =.ex= or =.exs=. This is a convention--files ending in '.ex' are intended to be compiled into byte codes and then run, whereas those ending in =.exs.= are more like programs in scripting languages and are effectively interpreted at the source level.

When you write tests for Elixir programs, you'll see that the application files have =.ex= extensions, whereas the tests have =.exs= because we don't need to keep compiled versions of the tests lying around.

** Assignment
In Elixir, the equals sign is not an assignment. Instead it's like an assertion. It succeeds if Elixir can find a way of making the left-hand side equal the right-hand side. Elixir calls the ~=~ symbol the match operator.

*** Elixir can match true by binding the variable
In this case, the left-hand side is a variable and the right-hand side is an integer literal, so Elixir can make the match true by binding the variable ~a~ to value ~1~.

#+begin_src iex
iex> a = 1
1
iex> a + 3
4
#+end_src

**** Example of incorrect match
The second line of code, ~1 = a~. It's another match, and it passes. The variable =a= already has the value =1= (it was set in the first line), so what's on the left of the equals sign is the same as what's on the right, and the match succeeds. But the third line, ~2 = a~, raises an error. You might expect it to assign =2= to =a=, as that would make the match succeed, but Elixir will only change the variable of a variable on the left side of an equals sign and replace it with the =value= on the right side. The failing line of code is the same as ~2 = 1~, which causes an error.

#+begin_src iex
iex> a = 1
1
iex> 1 = 1
1
iex> 2 = a
(MatchError) no match of right hand side value: 1
#+end_src

**** More complex matches
Elixir looks for a way to make the value of the left side the same as the value of the right side. The left side is a list containing three variables, and the right is a list of three values, so the two sides could be made the same by setting the variables to the corresponding values.

Elixir calls this process /pattern matching/. A pattern (the left side) is matched if the values (the right side) have the same structure and if each term in the pattern can be matched to the corresponding term in the values. A literal value in the pattern matches that exact value, and a variable in the pattern matches by taking on the corresponding value.

#+begin_src iex
iex> list = [ 1, 2, 3 ]
[1, 2, 3]
iex> [a, b, c ] = list
[1, 2, 3 ]
iex> a
1
iex> b
2
iex> c
3
#+end_src

Another example.

#+begin_src iex
iex> list = [1, 2, [3, 4, 5]]
[1, 2, [3, 4, 5]]
iex> [a, b, c] = list
[1, 2, [3, 4 ,5]]
iex> a
1
iex> b
2
iex> c
[3, 4, 5]
#+end_src

Example with a pattern containing some values and variables

#+begin_src iex
iex> list = [1, 2, 3]
[1, 2, 3]
iex> [a, 2, b] = list
[1, 2, 3]
iex> a
a
iex> b
3
#+end_src

**** Ignore a Value with _ (Underscore)
If we don't need to capture a value doing a match, we could use the special variable =_=. This acts like a variable but immediately discards any value given to it in a pattern match.

#+begin_src iex
iex> [1, _, _] = [ 1, 2 ,3]
[1, 2, 3]
iex> [1, _, _] = [1, "cat", "dog"]
[1, "cat", "dog"]
#+end_src

**** Variables bind once (per Match)
Once a variable has been bound to a value in matching process, it keeps that value for the remainder of the match.

#+begin_src iex
iex> [a, a] = [1, 1]
[1, 1]
iex> a
1
iex> [b, b] = [1, 2]
(MatchError) no match of right hand side vlaue: [1, 2]
#+end_src

- The first expression in this example succeeds because =a= is initially matched with the first =1= on the right side.
- the second expression, the first =b= matches the =1=. But the second =b= corresponds to the value 2 on the right. =b= cannot have two different values, and so the match fails.

If you want to force Elixir to use the existing value of the variable in the pattern, then prefix it with =^= (a caret). In Elixir we call this the /pin operator/.

#+begin_src iex
iex> a = 1
1
iex> a = 2
2
iex> ^a = 1
(MatchError) no match of right hand side value: 1
#+end_src

This also works if the variable is a component of a pattern:

#+begin_src iex
iex> a = 1
1
iex> [^a, 2, 3] = [1, 2, 3]
[1, 2, 3]
iex> a = 2
2
iex> [^a, 2] = [1, 2]
(MatchError) no match of right hand side value: [1, 2]
#+end_src

** Thanks to
[[https://pragprog.com/titles/elixir16/programming-elixir-1-6/][Programming Elixir 1.6]]
